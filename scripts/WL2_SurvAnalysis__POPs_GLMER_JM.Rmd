---
title: "WL2_Survival-Analysis"
author: "Julin Maloof"
date: '`r Sys.Date()`'
output: 
  html_document: 
    keep_md: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This script focuses on using populations as random effects.  See other scripts for analysis by elevation

# Survival Analysis 

See chapters 9 - 13 in tutorial: https://bookdown.org/content/4253/extending-the-discrete-time-hazard-model.html

## Libraries
```{r}
# install.packages("multilevelmod")
library(tidyverse) #includes lubridate, which we need 
library(magrittr)
library(ggrepel)
library(lme4)
library(ggdist)
library(tidymodels)
library(multilevelmod)
library(broom.mixed)
library(modelr)
tidymodels_prefer()
options(mc.cores = parallel::detectCores())
```

## Read in the data
```{r}
wl2_surv <- read_csv("../output/WL2_Traits/WL2_Mortality_2023.csv")
```

As weeks
```{r}
wl2_surv %>% filter(is.na(death.date),!is.na(survey.notes)) #no plants that seemed to disappear 
wl2_surv %>% filter(Genotype=="YO7_4_2")

wl2_surv_dates <- wl2_surv %>%  
  rename(parent.pop = pop) %>%
  mutate(parent.pop= str_replace(parent.pop, "Y08", "YO8")) %>% 
  mutate(parent.pop= str_replace(parent.pop, "Y04", "YO4")) %>% 
  filter(!is.na(parent.pop)) %>% 
  mutate(planting.date="7/19/23", #could try to make this more specific to when certain blocks were planted 
         last_fup_date=if_else(is.na(death.date), "10/27/23", death.date)) %>%  #need this to calculate survival times
  mutate(planting.date=mdy(planting.date), last_fup_date=mdy(last_fup_date)) %>% #convert to date objects
  mutate(os_weeks=as.duration(planting.date %--% last_fup_date) / dweeks(1), #observed number of weeks
         status=if_else(is.na(death.date), 0, 1)) %>% #0=censured (alive in this case), 1=dead
  filter(os_weeks > 0) %>% #there is one case of a plant that was dead at planting, so just removed it since this is survival post- transplanting
  select(-survey.notes)
head(wl2_surv_dates)
unique(wl2_surv_dates$os_weeks) %>% sort()
```


## Location Info

```{r}
gowersdist_WL2 <- read_csv("../output/Climate/Gowers_WL2.csv") 
gowersdist_WL2 %>% arrange(parent.pop)
```

```{r, fig.asp=1}
gowersdist_WL2 %>% 
  select(ends_with("GD")) %>%
  GGally::ggpairs(progress = FALSE)
```

```{r}
gowersdist_WL2_wide <- gowersdist_WL2 %>% select(-matches("BIOCLIM|FLINT")) %>%
  pivot_wider(values_from=c(GrwSsn_GD, Wtr_Year_GD), names_from = TimePd)
```


```{r}
wl2_surv_dates_loc <- left_join(wl2_surv_dates, gowersdist_WL2_wide)  %>%
  mutate(elevation.group = factor(elevation.group, levels= c("Low", "Mid", "High")))
wl2_surv_dates_loc 
```


## plot observed data

Need to summarize separately for pops and for elevation.  It is a mistake to average pops and then elevation, at least with respect to comparing to population naive models

### population-level summary
```{r}
wl2_obs.pop <- 
  wl2_surv_dates_loc %>% select(parent.pop, death.date, os_weeks, status, elevation.group, ends_with("GD")) %>%
  group_by(parent.pop) %>%
  mutate(total=n()) %>%
  group_by(parent.pop, os_weeks) %>%
  summarize(n.newly.dead=sum(status),
            across(c(total, elevation.group, ends_with("GD")), unique)) %>%
  ungroup() %>%
  complete(parent.pop, os_weeks, fill = list(n.newly.dead=0)) %>% # we have missing data for weeks where nobody died and we need to fill that in
  group_by(parent.pop) %>%
  mutate(total=unique(na.omit(total)), elevation.group=unique(na.omit(elevation.group)), # filling in the blanks from the complete() step above
         total.dead=cumsum(n.newly.dead),
         surviving = total - total.dead,
         prop.surviving = surviving/total,
         across(ends_with("GD"), \(x) unique(na.omit(x)))) %>%
  ungroup() %>%
#  bind_rows(week0.pop) %>%
#  select(parent.pop, elevation.group, os_weeks, prop.surviving) %>%
  arrange(parent.pop, os_weeks)

# Add a week 0 with all plants

wl2_obs.pop.0 <- wl2_obs.pop %>%
  filter(os_weeks==1) %>%
   mutate(os_weeks = 0,
          n.newly.dead = 0,
          total.dead = 0,
          surviving = total,
          prop.surviving = 1) %>%
   rbind(wl2_obs.pop) %>%
   arrange(parent.pop, os_weeks)

wl2_obs.pop.0 %>%
  ggplot(aes(x=os_weeks, y = prop.surviving, color = elevation.group)) +
  geom_smooth() +
  geom_point()

wl2_obs.pop.0 %>%
  ggplot(aes(x=os_weeks, y = prop.surviving, color = parent.pop)) +
  geom_line() +
  geom_point()
```


## Reformat to be one row per plant per week

```{r, eval=TRUE}
wl2_ind <- wl2_surv_dates %>% 
  complete(Genotype, last_fup_date) %>%
  group_by(Genotype) %>%
  mutate(across(c(-status, -last_fup_date, -os_weeks, -planting.date), \(x) ifelse(all(is.na(unique(x))), NA,unique(na.omit(x))))) %>%
  mutate(planting.date = unique(na.omit(planting.date)),
         os_weeks=as.duration(planting.date %--% last_fup_date) / dweeks(1),
           dead = ifelse((is.na(death.date) | mdy(death.date) > last_fup_date), 0, 1)) %>% # 0 is alive, 1 is dead
  filter(cumsum(dead) < 2) %>% # you can't die more than once
  ungroup() %>%  
  left_join(gowersdist_WL2_wide)

wl2_ind %>% select(Genotype, last_fup_date, os_weeks, dead)
```

# Modeling probability of event rather than event time

An alternative approach to hazard analysis is to model the probably of death as a function of time.  This is approach taken here.

## Discrete intervals

Modify the input data to add some factor variables
```{r}
wl2_ind <- wl2_ind %>% mutate(
  os_weeks_f = factor(str_pad(round(os_weeks, 1), 2, pad = "0")), # padding so it will sort correctly
  os_weeks_pop = factor(str_c(parent.pop,"_", os_weeks_f))
)
wl2_ind
```

Split data into establishment and survival data sets
```{r}
wl2_ind_estab <- wl2_ind %>% filter(os_weeks <= 3) %>%
  # compute status at week 3 for each plant
  group_by(Genotype) %>%
  summarize(dead=max(dead),
            across(c(block, bed, parent.pop, mf, contains("GD")), unique))

wl2_ind_surv <- wl2_ind %>% filter(os_weeks > 3) %>%
  mutate(os_weeks_f = factor(os_weeks))

wl2_estab_means <- wl2_ind_estab %>% # summary for plotting
  group_by(parent.pop) %>%
  summarize(survivorship = 1-mean(dead))
```


Create a plotting function for plotting the fits below:
FIXME
```{r, eval=FALSE}
# only fixed to work with survival models, not establishment
plot_fit_pop <- function(m, mname=NA, d=wl2_obs.pop.surv) {
  if(is.na(mname)) mname <- deparse(substitute(m)) 
  title = str_c(mname, ": ", {formula(m) %>% as.character %>% magrittr::extract2(1)})
  
  d %>% 
    data_grid(os_weeks, parent.pop, n=1) %>%
    mutate(os_weeks_f = factor(str_pad(round(os_weeks, 1), 2, pad = "0"))) %>% # padding so it will sort correctly

    # Add the discrete hazard probabilities
    add_epred_draws(m) %>% 
    
    # convert hazard to survival probability (1 - hazard)
    mutate(point.survivorship = 1 - .epred) %>%
    
    # calculate the cumulative survivorship
    arrange(parent.pop, .draw, os_weeks) %>% 
    group_by(parent.pop, .draw) %>%
    mutate(cum.survivorship = cumprod(point.survivorship)) %>%
    
    # calculate Bayesian highest density 95% credible intervals
    group_by(parent.pop, os_weeks) %>%
    point_interval(point.survivorship, cum.survivorship, .interval = hdci) %>%
    
    ggplot(aes(x = os_weeks, y = cum.survivorship, ymin = cum.survivorship.lower, ymax = cum.survivorship.upper, group = parent.pop)) +
    geom_ribbon(fill="grey50", alpha = .5) +
    geom_line(aes(color=parent.pop), lwd=1.5) +
    geom_point(aes(x=os_weeks, y = prop.surviving.w3, color = parent.pop), data=d, inherit.aes = FALSE) +
    scale_color_viridis_d() + 
    ggtitle(title) +
    theme(plot.title = element_text(size = 10))
}
```

# Establishment data set

```{r}
glmer.model <- 
  linear_reg() %>%
  set_engine("glmer", family = binomial)
```

```{r}
estab_wflow <- workflow() %>%
  add_variables(outcomes = dead, predictors = c(parent.pop, mf, block)) 

estab_fits <- tibble(wflow=list(
  pop = {estab_wflow %>% 
      add_model(glmer.model, formula = dead ~ (1|parent.pop))},
  
  pop.mf = {estab_wflow %>% 
      add_model(glmer.model, formula = dead ~ (1|parent.pop/mf))},
  
  pop.block = {estab_wflow %>% 
      add_model(glmer.model, formula = dead ~ (1|parent.pop) + (1|block))},
  
  pop.mf.block = {estab_wflow %>% 
      add_model(glmer.model, formula = dead ~ (1|parent.pop/mf) + (1|block))}
),
name=names(wflow)
) %>% 
  select(name,wflow)
estab_fits
```

```{r}
estab_fits <- estab_fits %>%
  mutate(fit = map(wflow, fit, data = wl2_ind_estab))
```

```{r}
estab_fits %>% mutate(glance=map(fit, glance)) %>% unnest(glance) %>% arrange(AIC) %>% select(-wflow:-sigma)
```

model with pop and block (but excluding mf) is best by AIC and BIC

get bootstrap predictions and plot
```{r}
estab_nd <- data_grid(wl2_ind_estab, parent.pop)

estab_predict_fun <- function(m, nd = estab_nd) {
  predict(m, 
          newdata = nd,
          type = "response",
          re.form = ~(1|parent.pop)
  ) %>%
    subtract(1, .) # convert hazard to survivorship
}

# 100 seconds
system.time (estab_fits <- estab_fits %>% 
               mutate(
                 bootstrap = map(fit, \(x) {
                   extract_fit_engine(x) %>% 
                     bootMer(FUN = estab_predict_fun,
                             re.form = ~ (1|parent.pop),
                             nsim = 1000,
                             parallel = "multicore",
                             ncpus = 7
                     ) } #bootMer
                 ),  
                 tidyboot = map(bootstrap, tidy, conf.int = TRUE),
                 tidyboot = map(tidyboot, \(x) cbind(estab_nd, x))
               ) # mutate
) # system.time
```


```{r}
estab_fits %>%
  select(name, tidyboot) %>%
  unnest(tidyboot) %>%
  ggplot(aes(x=parent.pop)) +
  geom_col(aes(y=survivorship), data = wl2_estab_means, fill="skyblue") +
  geom_pointrange(aes(y=statistic, ymax = conf.high, ymin = conf.low, color=name), position = position_dodge(width = .75)) +
  scale_color_viridis_d() +
  theme(axis.text.x = element_text(angle=90, hjust=1, vjust=.5))
  

# NOTE: need bootmer for standard errors on predictions
```

```{r}
estab_fits %>%
  select(name, bootstrap) %>%
  mutate(tidyboot = map(bootstrap, tidy, conf.int = TRUE)) %>%
  unnest(tidyboot)
```

Keep block but not mf

### is Gower's distance an important predictor?


```{r}
estab_GD_wflow <- workflow() %>%
  add_variables(outcomes = dead, predictors = c(parent.pop, mf, block, contains("GD"))) 

estab_GD_fits <- tibble(wflow=list(
  pop.block = {estab_GD_wflow %>% 
      add_model(glmer.model, formula = dead ~ (1|parent.pop) + (1|block))},
  
  GS_Recent = {estab_GD_wflow %>% 
      add_model(glmer.model, formula = dead ~ GrwSsn_GD_Recent + (1|parent.pop) + (1|block))},
  
  GS_Historical = {estab_GD_wflow %>% 
      add_model(glmer.model, formula = dead ~ GrwSsn_GD_Historical + (1|parent.pop) + (1|block))},
  
  WY_Recent = {estab_GD_wflow %>% 
      add_model(glmer.model, formula = dead ~ Wtr_Year_GD_Recent + (1|parent.pop) + (1|block))},
  
  WY_Historical = {estab_GD_wflow %>% 
      add_model(glmer.model, formula = dead ~ Wtr_Year_GD_Historical + (1|parent.pop) + (1|block))},
  
  GS_Recent_pop = {estab_GD_wflow %>% 
      add_model(glmer.model, formula = dead ~ GrwSsn_GD_Recent + (GrwSsn_GD_Recent|parent.pop) + (1|block))},
  
  GS_Historical_pop = {estab_GD_wflow %>% 
      add_model(glmer.model, formula = dead ~ GrwSsn_GD_Historical + (GrwSsn_GD_Historical|parent.pop) + (1|block))},
  
  WY_Recent_pop = {estab_GD_wflow %>% 
      add_model(glmer.model, formula = dead ~ Wtr_Year_GD_Recent + (Wtr_Year_GD_Recent|parent.pop) + (1|block))},
  
  WY_Historical_pop = {estab_GD_wflow %>% 
      add_model(glmer.model, formula = dead ~ Wtr_Year_GD_Historical + (Wtr_Year_GD_Historical|parent.pop) + (1|block))}
  
),
name=names(wflow)
) %>% 
  select(name,wflow) %>%
  mutate(fit = map(wflow, fit, data = wl2_ind_estab))



```

```{r}
estab_GD_fits %>% mutate(glance=map(fit, glance)) %>% unnest(glance) %>% arrange(AIC) %>% select(-wflow:-sigma)
```
For any given GD, including a random effect for (GD | parent.pop) fits worse

```{r}
estab_GD_fits %>% mutate(tidy=map(fit, tidy)) %>% unnest(tidy) %>%
  filter(str_detect(term, "GD")) %>%
  drop_na(p.value) %>%
  select(-wflow:-group) %>%
  arrange(p.value)

```

# Survival data set

check basic model forms
```{r}
surv_wflow <- workflow() %>%
  add_variables(outcomes = dead, predictors = c(parent.pop, mf, block, os_weeks, os_weeks_f)) 

surv_fits_1 <- tibble(wflow=list(
  pop = {surv_wflow %>% 
      add_model(glmer.model, formula = dead ~ (1|parent.pop))},
  
  pop.block = {surv_wflow %>% 
      add_model(glmer.model, formula = dead ~ (1|parent.pop) + (1|block))},
  
  pop.weeks_f ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~ os_weeks_f + (1|parent.pop))},
  
  pop.weeks_f.block ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~ os_weeks_f + (1|parent.pop) + (1|block))},
  
  pop.weeks_f.int ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~ os_weeks_f + (os_weeks_f|parent.pop))},
  
  pop.weeks_f.int.block ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~ os_weeks_f + (os_weeks_f|parent.pop) + (1|block))},
  
  pop.weeks ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~ os_weeks + (1|parent.pop))},
  
  pop.weeks.block ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~ os_weeks + (1|parent.pop) + (1|block))},
  
  pop.weeks.int ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~ os_weeks + (os_weeks_f|parent.pop))},
  
  pop.weeks.int.block ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~ os_weeks + (os_weeks_f|parent.pop) + (1|block))},
  
  pop.weeks.quad ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~ os_weeks + I(os_weeks^2) + (1|parent.pop))},
  
  pop.weeks.quad.block ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~ os_weeks + I(os_weeks^2) + (1|parent.pop) + (1|block))},
  
  pop.weeks.quad.int ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~ os_weeks + I(os_weeks^2) + (os_weeks_f|parent.pop))},
  
  pop.weeks.quad.quad.int ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~ os_weeks + I(os_weeks^2) + (os_weeks_f + I(os_weeks^2)|parent.pop))},
  
  pop.weeks.quad.int.block ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~ os_weeks + I(os_weeks^2) + (os_weeks_f|parent.pop) + (1|block))},
  
    pop.weeks.quad.quad.int.block ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~ os_weeks + I(os_weeks^2) + (os_weeks_f + I(os_weeks^2)|parent.pop) + (1|block))}
    
),
name=names(wflow)
) %>% 
  select(name,wflow)
surv_fits_1
```

This is slow!!
```{r}
system.time(
  surv_fits_1 <- surv_fits_1 %>%
  mutate(fit = map(wflow, fit, data = wl2_ind_surv))
)
```
get warnings
```{r}
surv_fits_1 <- surv_fits_1 %>%
  mutate(message=map_chr(fit, \(x) {extract_fit_engine(x) %>% .@optinfo %>% magrittr::extract2("message")}))

surv_fits_1 %>% select(name, message) %>%
  arrange(message, name)
```
No models where I had a time slope random effect for each pop converged.

```{r}
surv_fits_1 %>% 
  filter(!str_detect(message, "failure")) %>%
  mutate(glance=map(fit, glance)) %>% 
  unnest(glance) %>% 
  arrange(AIC) %>%
  select(-wflow:-sigma)
```

What if no time main-effect in RE interaction models?

```{r}
surv_wflow <- workflow() %>%
  add_variables(outcomes = dead, predictors = c(parent.pop, mf, block, os_weeks, os_weeks_f)) 

surv_fits_2 <- tibble(wflow=list(
  pop = {surv_wflow %>% 
      add_model(glmer.model, formula = dead ~ (1|parent.pop))},
  
  pop.block = {surv_wflow %>% 
      add_model(glmer.model, formula = dead ~ (1|parent.pop) + (1|block))},
  
  pop.weeks_f ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~ os_weeks_f + (1|parent.pop))},
  
  pop.weeks_f.block ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~ os_weeks_f + (1|parent.pop) + (1|block))},
  
  pop.weeks_f.int ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~  (os_weeks_f|parent.pop))},
  
  pop.weeks_f.int.block ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~  (os_weeks_f|parent.pop) + (1|block))},
  
  pop.weeks ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~ os_weeks + (1|parent.pop))},
  
  pop.weeks.block ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~ os_weeks + (1|parent.pop) + (1|block))},
  
  pop.weeks.int ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~  (os_weeks_f|parent.pop))},
  
  pop.weeks.int.block ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~  (os_weeks_f|parent.pop) + (1|block))},
  
  pop.weeks.quad ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~ os_weeks + I(os_weeks^2) + (1|parent.pop))},
  
  pop.weeks.quad.block ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~ os_weeks + I(os_weeks^2) + (1|parent.pop) + (1|block))},
  
  pop.weeks.quad.int ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~  I(os_weeks^2) + (os_weeks_f|parent.pop))},
  
  pop.weeks.quad.quad.int ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~  (os_weeks_f + I(os_weeks^2)|parent.pop))},
  
  pop.weeks.quad.int.block ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~  I(os_weeks^2) + (os_weeks_f|parent.pop) + (1|block))},
  
    pop.weeks.quad.quad.int.block ={surv_wflow %>% 
      add_model(glmer.model, formula = dead ~  (os_weeks_f + I(os_weeks^2)|parent.pop) + (1|block))}
    
),
name=names(wflow)
) %>% 
  select(name,wflow)
surv_fits_2
```

This is slow!!
```{r}
system.time(
  surv_fits_2 <- surv_fits_2 %>%
  mutate(fit = map(wflow, fit, data = wl2_ind_surv))
)
```
get warnings
```{r}
surv_fits_1 <- surv_fits_1 %>%
  mutate(message=map_chr(fit, \(x) {extract_fit_engine(x) %>% .@optinfo %>% magrittr::extract2("message")}))

surv_fits_1 %>% select(name, message) %>%
  arrange(message, name)
```


get bootstrap predictions and plot
```{r}
surv_nd <- data_grid(wl2_ind_surv, parent.pop)

surv_predict_fun <- function(m, nd = surv_nd) {
  predict(m, 
          newdata = nd,
          type = "response",
          re.form = ~(1|parent.pop)
  ) %>%
    subtract(1, .) # convert hazard to survivorship
}

# 100 seconds
system.time (surv_fits <- surv_fits %>% 
               mutate(
                 bootstrap = map(fit, \(x) {
                   extract_fit_engine(x) %>% 
                     bootMer(FUN = surv_predict_fun,
                             re.form = ~ (1|parent.pop),
                             nsim = 1000,
                             parallel = "multicore",
                             ncpus = 7
                     ) } #bootMer
                 ),  
                 tidyboot = map(bootstrap, tidy, conf.int = TRUE),
                 tidyboot = map(tidyboot, \(x) cbind(surv_nd, x))
               ) # mutate
) # system.time
```


```{r}
surv_fits %>%
  select(name, tidyboot) %>%
  unnest(tidyboot) %>%
  ggplot(aes(x=parent.pop)) +
  geom_col(aes(y=survivorship), data = wl2_surv_means, fill="skyblue") +
  geom_pointrange(aes(y=statistic, ymax = conf.high, ymin = conf.low, color=name), position = position_dodge(width = .75)) +
  scale_color_viridis_d() +
  theme(axis.text.x = element_text(angle=90, hjust=1, vjust=.5))
  

# NOTE: need bootmer for standard errors on predictions
```

### simple2: time only

```{r}
s.m2 <- brm(n.newly.dead | trials(n)  ~ 0 + os_weeks_f, 
          prior(normal(0, 4), class = b),
          family = "binomial",
          chains = 4, cores = 4, refresh = 0,
          data = na.omit(wl2_obs.pop.surv),
          save_pars = save_pars(all = TRUE)) %>%
  add_criterion("loo", moment_match = TRUE)
```

```{r}
summary(s.m2)
```

The estimates above are on the logit scale.  Transform them back to hazard probabilities
```{r}
fixef(s.m2) %>% inv_logit_scaled()
```

```{r}
plot(s.m2, ask = FALSE, nvariables = 3)
```
```{r}
plot_fit_pop(s.m2)
```


### time and pop

```{r}
s.m3 <- brm(n.newly.dead | trials(n)  ~ 0 + os_weeks_f + (1|parent.pop), 
          prior(normal(0, 4), class = b),
          family = "binomial",
          chains = 4, cores = 4, refresh = 0,
          data = wl2_obs.pop.surv,
          save_pars = save_pars(all = TRUE)) %>%
  add_criterion("loo", moment_match = TRUE)
```

```{r}
summary(s.m3)
```
```{r}
plot(s.m3, ask = FALSE, nvariables = 3)
```


from logit to hazard probabilities:
```{r}
fixef(s.m3) %>% inv_logit_scaled()
```
survivorship
```{r}
wl2_obs.pop.surv %>% droplevels() %>% data_grid(os_weeks_f, parent.pop, n=1) %>%
  add_epred_draws(s.m3) %>% 
  # convert hazard to survival probability (1 - hazard)
  mutate(point.survivorship = 1 - .epred) %>%
  
  # calculate the cumulative survivorship
  arrange(parent.pop, .draw, os_weeks_f) %>% 
  group_by(parent.pop, .draw) %>%
  mutate(cum.survivorship = cumprod(point.survivorship)) %>%
  group_by(parent.pop, os_weeks_f) %>%
  point_interval(point.survivorship, cum.survivorship, .interval = hdci) 
```

```{r}
plot_fit_pop(s.m3)
```


```{r}
loo_compare(s.m2, s.m3)
```

pop still matters

### week and pop interaction

```{r}
s.m4 <- brm(n.newly.dead | trials(n)  ~ 0 + os_weeks_f + (os_weeks_f|parent.pop), 
          prior(normal(0, 4), class = b),
          family = "binomial",
          chains = 4, cores = 4, refresh = 0,
          data = wl2_obs.pop.surv,
          save_pars = save_pars(all = TRUE)) %>%
  add_criterion("loo", moment_match = TRUE)
```

```{r}
summary(s.m4)
```

```{r}
plot(s.m4, ask = FALSE, nvariables = 3)
```


from logit to hazard probabilities:
```{r}
fixef(s.m4) %>% inv_logit_scaled()
```
survivorship
```{r}
wl2_obs.pop.surv %>% droplevels() %>% data_grid(os_weeks_f, parent.pop, n=1) %>%
  add_epred_draws(s.m4) %>% 
  # convert hazard to survival probability (1 - hazard)
  mutate(point.survivorship = 1 - .epred) %>%
  
  # calculate the cumulative survivorship
  arrange(parent.pop, .draw, os_weeks_f) %>% 
  group_by(parent.pop, .draw) %>%
  mutate(cum.survivorship = cumprod(point.survivorship)) %>%
  group_by(parent.pop, os_weeks_f) %>%
  point_interval(point.survivorship, cum.survivorship, .interval = hdci) 
```

```{r, fig.height=10}
plot_fit_pop(s.m4) + facet_wrap(~parent.pop) + theme(legend.position = "none")
```


```{r}
loo_compare(s.m2, s.m3, s.m4)
```
s.m4 preferred

## Continuous time

### linear

#### linear time only
```{r}
s.m9 <- brm(n.newly.dead | trials(n)  ~ os_weeks, 
          prior(normal(0, 4), class = b),
          family = "binomial",
          chains = 4, cores = 4, refresh = 0,
          data = wl2_obs.pop.surv,
          save_pars = save_pars(all = TRUE)) %>%
  add_criterion("loo", moment_match = TRUE)
```

```{r}
summary(s.m9)
```

```{r}
plot(s.m9, nvariables=3, ask=FALSE)
```


logit to hazard probabilities
```{r}
fixef(s.m9) %>% inv_logit_scaled()
```

```{r}
plot_fit_pop(s.m9)

```


#### linear with time and pops

```{r}
s.m10 <- brm(n.newly.dead | trials(n)  ~ os_weeks + (1|parent.pop), 
          prior(normal(0, 4), class = b),
          family = "binomial",
          chains = 4, cores = 4, refresh = 0,
          data = wl2_obs.pop.surv,
          save_pars = save_pars(all = TRUE)) %>%
  add_criterion("loo", moment_match = TRUE)
```

```{r}
plot(s.m10, ask = FALSE, nvariables = 3)
```

```{r}
summary(s.m10)
```

```{r, fig.height=10}
plot_fit_pop(s.m10) + facet_wrap(~parent.pop) +   theme(legend.position = "none")
```


```{r}
loo_compare(s.m2, s.m3, s.m4, s.m6, s.m9, s.m10)
```

pops matter

#### linear with time and random slope for each pop

```{r}
s.m11 <- brm(n.newly.dead | trials(n)  ~ os_weeks +(os_weeks|parent.pop), 
          prior(normal(0, 4), class = b),
          family = "binomial",
          chains = 4, cores = 4, refresh = 0,
          data = wl2_obs.pop.surv,
          save_pars = save_pars(all = TRUE),
          control = list(adapt_delta = 0.9)) %>%
  add_criterion("loo", moment_match = TRUE)
```

```{r}
plot(s.m11, ask = FALSE, nvariables = 3)
```


```{r}
summary(s.m11)
```

```{r, fig.height=10}
plot_fit_pop(s.m11) + facet_wrap(~parent.pop) +   theme(legend.position = "none")
```


```{r}
loo_compare(s.m2, s.m3, s.m4, s.m6, s.m9, s.m10, s.m11)
```

#### Linear without a main effect for os_weeks
```{r}
s.m12 <- brm(n.newly.dead | trials(n)  ~ (os_weeks|parent.pop), 
         # prior(normal(0, 4), class = b),
          family = "binomial",
          chains = 4, cores = 4, #refresh = 0,
          data = wl2_obs.pop.surv,
          save_pars = save_pars(all = TRUE),
          control = list(adapt_delta = 0.9)) %>%
  add_criterion("loo", moment_match = TRUE)
```

```{r}
plot(s.m12, ask = FALSE, nvariables = 3)
```


```{r}
summary(s.m12)
summary(s.m12.original)
```

```{r, fig.height=10}
plot_fit_pop(s.m12) + facet_wrap(~parent.pop) +   theme(legend.position = "none")
```

```{r}
ranef(s.m12)
```


```{r}
loo_compare(s.m2, s.m3, s.m4, s.m6, s.m9, s.m10, s.m11, s.m12)
```

Fits as well as m11


### quadratic

```{r}
s.m13 <- brm(n.newly.dead | trials(n)  ~ os_weeks + I(os_weeks^2) + (1|parent.pop), 
          prior(normal(0, 4), class = b),
          family = "binomial",
          chains = 4, cores = 4, refresh = 0,
          data = wl2_obs.pop.surv,
          save_pars = save_pars(all = TRUE)) %>%
  add_criterion("loo", moment_match = TRUE)
```

```{r}
plot(s.m13, ask = FALSE, nvariables = 3)
```

```{r}
summary(s.m13)
```

```{r, fig.height=10}
plot_fit_pop(s.m13) + facet_wrap(~parent.pop) +   theme(legend.position = "none")
```

```{r}
loo_compare(s.m2, s.m3, s.m4, s.m6, s.m9, s.m10, s.m11, s.m12, s.m13)
```
The linear is preferred

#### Quadratic with linear slope for pop

```{r}
s.m14 <- brm(n.newly.dead | trials(n)  ~ os_weeks + I(os_weeks^2) + (os_weeks|parent.pop), 
          prior(normal(0, 4), class = b),
          family = "binomial",
          chains = 4, cores = 4, refresh = 0,
          data = wl2_obs.pop.surv,
          save_pars = save_pars(all = TRUE)) %>%
  add_criterion("loo", moment_match = TRUE)
```

```{r}
plot(s.m14, ask = FALSE, nvariables = 3)
```

```{r}
summary(s.m14)
```

```{r, fig.height=10}
plot_fit_pop(s.m14) + facet_wrap(~parent.pop) +   theme(legend.position = "none")
```

```{r}
loo_compare(s.m2, s.m3, s.m4, s.m6, s.m9, s.m10, s.m11, s.m12, s.m13, s.m14)
```
Quadratic and linear equivalent


#### Quadratic with quadratic slope for pop
```{r}
s.m15 <- brm(n.newly.dead | trials(n)  ~ os_weeks + I(os_weeks^2) + (os_weeks + I(os_weeks^2)|parent.pop), 
          prior(normal(0, 4), class = b),
          family = "binomial",
          chains = 4, cores = 4, refresh = 0,
          data = wl2_obs.pop.surv,
          save_pars = save_pars(all = TRUE)) %>%
  add_criterion("loo", moment_match = TRUE)
```

```{r}
plot(s.m15, ask = FALSE, nvariables = 3)
```

```{r}
summary(s.m15)
```

```{r, fig.height=10}
plot_fit_pop(s.m15) + facet_wrap(~parent.pop) +   theme(legend.position = "none")
```

```{r}
loo_compare(s.m2, s.m3, s.m4, s.m6, s.m9, s.m10, s.m11, s.m12, s.m13, s.m14, s.m15)
```

#### Quadratic, no fixed time effects

```{r}
s.m16 <- brm(n.newly.dead | trials(n)  ~   (os_weeks + I(os_weeks^2)|parent.pop), 
         # prior(normal(0, 4), class = b),
          family = "binomial",
          chains = 4, cores = 4, refresh = 0,
          data = wl2_obs.pop.surv,
          save_pars = save_pars(all = TRUE)) %>%
  add_criterion("loo", moment_match = TRUE)
```

```{r}
plot(s.m16, ask = FALSE, nvariables = 3)
```

```{r}
summary(s.m16)
```

```{r, fig.height=10}
plot_fit_pop(s.m16) + facet_wrap(~parent.pop) +   theme(legend.position = "none")
```

```{r}
loo_compare(s.m2, s.m3, s.m4, s.m6, s.m9, s.m10, s.m11, s.m12, s.m13, s.m14, s.m15, s.m16)
```

# Summary

The best survival model is linear with respect time, with random intercept and slope for each population.

# What about random effect for block?

To look at random effect for block we need to use Bernoulli instead of binomial (so we can use one observation per plant).

We can start with `wl2_surv_dates_loc` but we have to fill it in for data points before each plant died.

```{r}
x <- wl2_surv_dates_loc %>% 
  complete(Genotype, last_fup_date) %>%
  filter(Genotype == "BH_1_1") %>% 
  pull(block)

x

is.na(unique(x))
```

## NOT WORKING CORRECTLY
```{r, eval=FALSE}
wl2_surv_dates_ind <- wl2_surv_dates %>% 
  complete(Genotype, last_fup_date) %>%
  group_by(Genotype) %>%
  mutate(across(c(-status, -last_fup_date, -os_weeks, -planting.date), \(x) ifelse(all(is.na(unique(x))), NA,unique(na.omit(x))))) %>%
  mutate(planting.date = unique(na.omit(planting.date)),
         os_weeks=as.duration(planting.date %--% last_fup_date) / dweeks(1),
           status = ifelse((is.na(death.date) | mdy(death.date) > last_fup_date), 0, 1)) %>% # 0 is alive, 1 is dead
  filter(cumsum(status) < 2) %>% # you can't die more than once
  ungroup() %>%  
  left_join(gowersdist_WL2 %>% filter(TimePd == "Historical"))

wl2_surv_dates_ind %>% select(Genotype, last_fup_date, os_weeks, status)
```

Can I get the original data back out?
```{r}
wl2_surv_dates_ind %>%
  group_by(parent.pop) %>%
  mutate(total=length(unique(Genotype))) %>%
  group_by(parent.pop, os_weeks) %>%
    summarize(n.newly.dead=sum(status),
            across(c(total, elevation.group, ends_with("GD")), unique)) %>%
  ungroup() %>%
  select(parent.pop, os_weeks, n.newly.dead, total)
  
```
```{r}
wl2_obs.pop
```


```{r}
wl2_surv_dates_ind %>% group_by(Genotype) %>% summarise(status=sum(status)) %>% arrange(desc(status))
```

Redo s.m12 to make sure results are the same

```{r, eval=FALSE}
s.m12.bern <- brm(status  ~ (os_weeks|parent.pop/Genotype), 
         # prior(normal(0, 4), class = b),
          family = "bernoulli",
          chains = 4, cores = 4, #refresh = 0,
          data = wl2_surv_dates_ind,
          save_pars = save_pars(all = TRUE),
          control = list(adapt_delta = 0.9)) %>%
  add_criterion("loo", moment_match = TRUE)
```

```{r}
plot(s.m12.bern, ask = FALSE, nvariables = 3)
```


```{r}
summary(s.m12)
summary(s.m12.bern)
```

```{r, fig.height=10}
plot_fit_pop(s.m12.bern) + facet_wrap(~parent.pop) +   theme(legend.position = "none")
```

